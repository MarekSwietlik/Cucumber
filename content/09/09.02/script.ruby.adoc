include::./title.adoc[]

We need a new directory to contain our support code. the conventional place to put it is here, in a `support` directory underneath `features`.

[source, sh]
----
mkdir features/support
----

There’s a special file in support that Cucumber always loads first, called `env.rb`. You can use this to boot up the system that you’re testing.

[source, sh]
----
touch features/support/env.rb
----

In this case, our system is just a domain model, but we can load it here instead of from the step definitions.

[source, ruby]
----
include::../code/ruby/01-require-the-app-from-env-rb/features/support/env.rb[lines=1]
----

The most obvious duplication in the step definition code is for Sean shouting a message.

[source,rb]
----
include::../code/ruby/02-create-world-module/features/step_definitions/steps.rb[lines=20..42]
----

Let’s imagine we had a helper method we could call like this, instead. Wouldn’t that be neater?

[source,ruby]
----
include::../code/ruby/03-extract-shout-helper-to-world-module/features/step_definitions/steps.rb[lines=20..22]
----

Every time Cucumber runs a scenario, it creates a new object, called the _World_. Each step definition runs inside this instance of the world, almost as though it were a method on that object. We can extend the methods available on the world (and so the methods available to the step defintions) by first defining them on a Ruby module, then registering that module with Cucumber.

We’ll create a new file in the `support` directory to contain our extensions to the world.shot::[1]

[source,sh]
----
touch features/support/world.rb
----

Now we define a module,

[source,ruby]
----
include::../code/ruby/02-create-world-module/features/support/world.rb[lines=1..2]
----

and tell Cucumber to make it part of the world.

[source,ruby]
----
include::../code/ruby/02-create-world-module/features/support/world.rb[lines=4]
----

Finally, we define our new helper method on this module and paste in the code from the step definition.

[source,rb]
----
include::../code/ruby/03-extract-shout-helper-to-world-module/features/support/world.rb[lines=1..7]
----

Let’s run Cucumber to check everything’s still working… Good.

[source,sh]
----
RUN CUCUMBER!!!!
----

Now we can use that new method everywhere… and check we haven’t broken anything… done.

[source,ruby]
----
...
include::../code/ruby/04-use-shout-helper-everywhere/features/step_definitions/steps.rb[lines=24..30]
...
----

==== Move instance variables behind helper methods

Notice that the helper method we extracted uses that `@messages_shouted_by` instance variable.

[source,ruby]
----
include::../code/ruby/04-use-shout-helper-everywhere/features/support/world.rb[lines=1..7]
----

We're using this instance variable in this assertion step shot::[2]

[source,ruby]
----
include::../code/ruby/04-use-shout-helper-everywhere/features/step_definitions/steps.rb[lines=61..63]
----

This works because the helper methods are mixed into the same World object as the step definitions, so they can all see the same instance variables.

However, we don’t like sharing state across the support API boundary like this. Things can get complicated quickly when you have code spread all over your step definitions and support directory that’s depending on these instance variables.

It’s better to push the state behind the support API.

Let’s extract this variable into a new method on the World that returns the instance variable, initializing it with an empty hash if it’s never been accessed before.

[source,ruby]
----
include::../code/ruby/05-push-messages_shouted_by-behind-a-method-in-world/features/support/world.rb[lines=8..10]
----

Now we can use this method in the step definitions,

[source,rb]
----
include::../code/ruby/05-push-messages_shouted_by-behind-a-method-in-world/features/step_definitions/steps.rb[lines=60..62]
----

and we no longer need to initialize it in this before hook.

[source,ruby]
----
include::../code/ruby/05-push-messages_shouted_by-behind-a-method-in-world/features/step_definitions/steps.rb[lines=3..5]
----

Let’s run cucumber to check we haven’t broken anything….. good.

[source,sh]
----
bundle exec cucumber
----

And run cucumber to check we’re still green.

[source,sh]
----
bundle exec cucumber
----

shot::[3, WE LEFT HERE]

We can follow the same steps for the `@network` instance variable. Make the accessor

[source,ruby]
----
include::../code/ruby/06-move-network-to-an-accessor-in-world/features/support/world.rb[lines=11..13]
----

Replace all the calls.

[source,ruby]
----
include::../code/ruby/06-move-network-to-an-accessor-in-world/features/step_definitions/steps.rb[lines=7..15]
----

And run cucumber.

[source,sh]
----
bundle exec cucumber
----

Now we can remove this before hook altogether. 

[source,ruby]
----
include::../code/ruby/03-use-sean_shout-everywhere/features/step_definitions/steps.rb[lines=3..7]
----

And we run cucumber one last time.

[source,sh]
----
bundle exec cucumber
----

